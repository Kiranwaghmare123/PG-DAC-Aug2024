----------------------------------------
### Day 10 : Algorithms and Data Structures
    ----------------------------------------
    Topic: Introduction to ADS
    Date: 04/10/2024
    Meeting ID: 832 1579 8576
    Passcode:	806920
    ----------------------------------------
    Topics:
    	-Bubble Sort
    	-Selection Sort
    	-Insertion Sort
    	-Divide and Conquer Technique
    	-Merge Sort
    	-Quick Sort
    	-Hashing

### Searching:
    1. Linear Search:
    	Best case : O(1)
    	Worst Case : O(n)
    Space Complexity: O(1)	
    	
    2. Binary search:
    	Best case : O(1) (Mid element = key)
    	Worst Case : O(log n) 
    Space Complexity: O(1)	

### Sorting:
--------
### Bubble sort:
    
    Best case : O(n)
    Worst Case : O(n^2) 
    Space Complexity: O(1)	
    Stable sorting technique
    Internal Sorting

### Selection Sort:
    -----------------
    Time complexity: O(n^2)
    Best case : O(n^2)
    Average case : O(n^2)
    Worst case : O(n^2)
    Space Complexity: O(1)	
    Not stable
    Internal Sorting	

### Insertion Sort:
    ------------------
    Time complexity:
    Best case: O(n)
    Average case: O(n^2)
    Worst case: O(n^2)
    Space Complexity: O(1)	
    Stable sorting technique
    Internal sorting

### Divide and Conquer Strategy:
    --------------------------------
    Divide and Conquer is an algorithm design paradigm that solves as problem using following steps:
    
    1. Dividing: Breaking the problem into smaller subproblems
    2. Conquering: Solving each subproblem recursively.
    3. Combining: Merging the solutions of subproblems to form the solution to the original problem.
    
    Characteristics:
    ----------------
    1. Recursion: Divide and Conquer often uses recursive technique.
    2. Efficiecy: Helps to reduce complex problem into simple, managable ones.
    3. Optimal Subsolution: The problem can be broken into smaller subproblems, each of which is a problem.
    4. Overlapping: Subproblems are independent and do not share the data.
    
    Advantage:
    ----------
    1. Efficiency: reduces the complexity of a problem.
    2. Parallelism: Subproblems can often be solved independely, making it suitable for parallel computing.
    3. Modularity: Problem are solved in a modular way, improving code structure and redability.
    
    Disadvantages:
    ----------------
    1. Space complexity
    2. Overhead for execution
    
    Application:
    --------------
    1. Searching: Binary search
    2. Sorting: Merge sort and Quick sort
    3. Matrix Multiplication: Strassen's algorithm

### Merge Sort:
-----------
    Time Complexity:O(nlogn)
    Space Complexity:O(n)
    Both sorting: Internal/External
    stable technique

### Quick sort:
------------
    Best case: O(nlogn)
    Average case: O(nlogn)
    Worst case: O(n^2)
    Space complexity:O(log n): due to recursion
    Not stable sorting technique
    Internal sorting technique

### Heap Sort:
----------
    Best case: O(nlogn)
    Average case: O(nlogn)
    Worst case: O(nlogn)
    Space complexity:O(1)
    Not stable sorting technique
    Internal sorting technique
